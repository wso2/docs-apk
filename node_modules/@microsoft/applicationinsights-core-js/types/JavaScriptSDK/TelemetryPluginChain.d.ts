import { ITelemetryItem } from "../JavaScriptSDK.Interfaces/ITelemetryItem";
import { IProcessTelemetryContext } from "../JavaScriptSDK.Interfaces/IProcessTelemetryContext";
import { ITelemetryPluginChain } from "../JavaScriptSDK.Interfaces/ITelemetryPluginChain";
import { ITelemetryPlugin } from "../JavaScriptSDK.Interfaces/ITelemetryPlugin";
export declare class TelemetryPluginChain implements ITelemetryPluginChain {
    /**
     * Returns the underlying plugin that is being proxied for the processTelemetry call
     */
    getPlugin: () => ITelemetryPlugin;
    /**
     * Returns the next plugin
     */
    getNext: () => ITelemetryPluginChain;
    /**
     * Sets the next proxy to be executed as the next plugin
     * (Should only be used during initialization, which is why it's not defined on the interface)
     */
    setNext: (nextPlugin: ITelemetryPluginChain) => void;
    /**
     * Call back for telemetry processing before it it is sent
     * @param env - This is the current event being reported
     * @param itemCtx - This is the context for the current request, ITelemetryPlugin instances
     * can optionally use this to access the current core instance or define / pass additional information
     * to later plugins (vs appending items to the telemetry item)
     */
    processTelemetry: (env: ITelemetryItem, itemCtx: IProcessTelemetryContext) => void;
    /**
     * Internal flag used to try and identify root cause failures
     */
    private _hasRun;
    constructor(plugin: ITelemetryPlugin, defItemCtx: IProcessTelemetryContext);
}
